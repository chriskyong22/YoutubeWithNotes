import React, { useState, useCallback } from "react"
import { notesType, noteType } from "../Models/Note"
import { videoType } from "../Models/Video"
import { getTimestamp } from "../Utilities/helper"
import { append } from "../Services/DBService"
import { v4 as uuidv4 } from "uuid"

interface inputState {
    beginTime: string;
    text: string;
    endTime: string;
}

interface chatBoxProps { 
    player: YT.Player | undefined;
    video: videoType;
    setMessages: React.Dispatch<React.SetStateAction<notesType["notes"]>>
}

export const Chatbox: React.FC<chatBoxProps> = ({player, video, setMessages}): JSX.Element => {

    const getCurrentTime = () => {
        return player?.getCurrentTime();
    }

    const [input, setInput] = useState<inputState>({
        beginTime: "",
        text: "",
        endTime: ""
    })

    const storeNewMessage = async (newMessage: noteType["note"]): Promise<void> => {
        console.log("Storing the new message!");
        await append(video, newMessage);
    }

    const handleKeyPress = (event: React.KeyboardEvent<HTMLTextAreaElement>): void => {
        if (event.key === "Enter") {
            event.preventDefault();
            if (!input.text) {
                return;
            }
            console.log(input.beginTime);
            let endTime = getCurrentTime();
            let newMessage: noteType["note"] = [
                `${input.beginTime}-${(endTime) ? endTime : ""}`,
                input.text,
                uuidv4()
            ];
            
            setMessages((oldMessages) => [...oldMessages, newMessage])

            storeNewMessage(newMessage);

            setInput({
                beginTime: "",
                text: "",
                endTime: ""
            });
            
        }
    }

    const handleChange = (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
        setInput((oldInput) => {
            return {
                ...oldInput,
                beginTime: oldInput.beginTime === "" || oldInput.beginTime === 'NaN' ? getCurrentTime() + "" : oldInput.beginTime,
                text: event.target.value
            }
        });
    }

    const changeBeginningTimeStamp = (event: React.ChangeEvent<HTMLInputElement>): void => {
        
        // Number is already set (set by typing a message)
        // Autogenerated by handleChange on the messsages textarea
        if (isNumber(event.target.value)) {
            setInput({
                ...input, 
                beginTime: event.target.value
            })
            return;
        }

        let partitions = event.target.value.split(':');
        // There is no valid input, reset it back to blank
        if (partitions.length == 1) {
            console.log("Invalid Input");
            setInput({
                ...input, 
                beginTime: ""
            })
            return;
        }

        // Valid input detected, converting it to seconds (since we use seconds 
        // to store the timestamps)
        if (partitions[partitions.length - 1].length === 3) {
            let newTimestamp = event.target.value;
            newTimestamp = newTimestamp.replaceAll(':', "");

            // Convert to even length
            if (newTimestamp.length % 2 == 1) {
                if (newTimestamp[0] === "0") {
                    newTimestamp = newTimestamp.substring(1);
                } else {
                    newTimestamp = "0" + newTimestamp;
                }
            }
            let _newTimestamp = newTimestamp.match(/.{2}/g)?.join(':');
            if (_newTimestamp) {
                event.target.value = _newTimestamp;
            }
        }

        partitions = event.target.value.split(':');
        // Changing one of the values in the timestamp.
        let convertedToSeconds = 0;
        for (let partition = partitions.length - 1, secondsInAUnit = 1; partition >= 0; partition--, secondsInAUnit *= 60) {
            for (let LSB = 1, base10 = 1; LSB >= 0; LSB--, base10 = 10) {
                // If any of the places are invalid input, it will become NaN and thus go back to ""
                convertedToSeconds += parseInt(partitions[partition][LSB]) * base10 * secondsInAUnit;
            }
        }
        
        console.log(convertedToSeconds);
        setInput({
            ...input, 
            beginTime: `${convertedToSeconds === NaN ? "" : convertedToSeconds}`
        })
    }


    const debounce = (func: (args: any) => any, timeout: number = 1500) => {
        let timer: NodeJS.Timeout;
        return (event: React.ChangeEvent<HTMLInputElement>): void => {
            clearTimeout(timer);
            event.target.style.backgroundColor = 'red';
            timer = setTimeout(() => {
                console.log("Timeout");
                event.target.style.backgroundColor = 'white';
                func(event);
            }, timeout);
        };
    }

    const processChange = useCallback(debounce(changeBeginningTimeStamp), []);
    
    const isNumber = (s: string): boolean => {
        return !isNaN(Number(s)) && s !== '';
    }

    return (
        <>
            <textarea
                placeholder="Send a message"
                name="messages"
                className="ListItemSendMessages Hidden-Scrollable-Element"
                value={input.text}
                onKeyDown={handleKeyPress}
                onChange={handleChange}
            />
            <input
                type="text"
                placeholder="Beginning Timestamp HH:MM:SS"
                name="beginTime"
                value={isNumber(input.beginTime) ? getTimestamp(parseFloat(input.beginTime)) : input.beginTime}
                onChange={(event) => {
                    setInput({
                        ...input, 
                        beginTime: event.target.value
                    })
                    processChange(event)
                }}
            />
        </>
    )
}

export const MemoizedChatbox = React.memo(Chatbox);